// app/api/export/route.ts
// Export page as downloadable ZIP with extracted Tailwind styles

import { NextRequest, NextResponse } from 'next/server';
import { renderToString } from 'react-dom/server';
import JSZip from 'jszip';
import { PageRenderer } from '@/components/PageRenderer';
import { componentRegistry } from '@/components/sections/registry';
import type { PageNode, SectionNode } from '@/types/section-system';

// Tailwind extractor utilities
import { extractTailwindClasses, generateTailwindCSS } from '@/lib/export/tailwind-extractor';
import { extractUsedComponents } from '@/lib/export/component-extractor';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { 
      page,
      format = 'static', // 'static' | 'nextjs' | 'remix'
      includeSource = false,
    } = body as {
      page: PageNode;
      format?: string;
      includeSource?: boolean;
    };

    if (!page || !page.sections) {
      return NextResponse.json(
        { error: 'Invalid page data' },
        { status: 400 }
      );
    }

    // Generate ZIP based on format
    let zipBuffer: Buffer;
    
    switch (format) {
      case 'nextjs':
        zipBuffer = await exportAsNextJS(page, includeSource);
        break;
      case 'remix':
        zipBuffer = await exportAsRemix(page);
        break;
      case 'static':
      default:
        zipBuffer = await exportAsStatic(page);
        break;
    }

    // Return ZIP as download
    return new NextResponse(zipBuffer, {
      headers: {
        'Content-Type': 'application/zip',
        'Content-Disposition': `attachment; filename="grid20-export-${Date.now()}.zip"`,
      },
    });

  } catch (error) {
    console.error('Export error:', error);
    return NextResponse.json(
      { error: 'Export failed' },
      { status: 500 }
    );
  }
}

/**
 * Export as static HTML/CSS/JS
 */
async function exportAsStatic(page: PageNode): Promise<Buffer> {
  const zip = new JSZip();
  
  // Render page to HTML
  const html = renderToString(<PageRenderer page={page} />);
  
  // Extract used Tailwind classes
  const classes = extractTailwindClasses(html);
  const tailwindCSS = await generateTailwindCSS(classes, page.brand);
  
  // Generate index.html
  const indexHTML = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${page.meta.title}</title>
  <meta name="description" content="${page.meta.description}">
  ${page.meta.canonical ? `<meta rel="canonical" href="${page.meta.canonical}">` : ''}
  
  <!-- Open Graph -->
  ${Object.entries(page.meta.og || {}).map(([key, value]) => 
    `<meta property="og:${key}" content="${value}">`
  ).join('\n  ')}
  
  <!-- Styles -->
  <link rel="stylesheet" href="styles.css">
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=${page.brand.fonts.heading.replace(' ', '+')}:wght@400;600;700&family=${page.brand.fonts.body.replace(' ', '+')}:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <div id="root">${html}</div>
  
  <!-- Optional JS for interactions -->
  <script src="script.js"></script>
</body>
</html>`;

  // Generate styles.css
  const stylesCSS = `/* Generated by Grid 2.0 */

/* Brand Tokens */
:root {
  /* Colors */
  ${Object.entries(page.brand.colors.brand).map(([key, value]) => 
    `--color-brand-${key}: ${value};`
  ).join('\n  ')}
  
  ${Object.entries(page.brand.colors.gray).map(([key, value]) => 
    `--color-gray-${key}: ${value};`
  ).join('\n  ')}
  
  /* Typography */
  --font-heading: '${page.brand.fonts.heading}', system-ui, sans-serif;
  --font-body: '${page.brand.fonts.body}', system-ui, sans-serif;
  
  /* Spacing */
  --spacing-tight: ${page.brand.spacing.tight};
  --spacing-normal: ${page.brand.spacing.normal};
  --spacing-relaxed: ${page.brand.spacing.relaxed};
  
  /* Radius */
  --radius-sm: ${page.brand.radius.sm};
  --radius-md: ${page.brand.radius.md};
  --radius-lg: ${page.brand.radius.lg};
  --radius-xl: ${page.brand.radius.xl};
}

/* Tailwind Styles (tree-shaken) */
${tailwindCSS}

/* Custom Styles */
.font-heading { font-family: var(--font-heading); }
.font-body { font-family: var(--font-body); }

/* Responsive utilities */
@media (max-width: 640px) {
  .hide-mobile { display: none; }
}

/* Print styles */
@media print {
  .no-print { display: none; }
}`;

  // Generate minimal JS for interactions
  const scriptJS = `// Grid 2.0 Generated Script

// Smooth scroll for anchor links
document.querySelectorAll('a[href^="#"]').forEach(anchor => {
  anchor.addEventListener('click', function (e) {
    e.preventDefault();
    const target = document.querySelector(this.getAttribute('href'));
    if (target) {
      target.scrollIntoView({ behavior: 'smooth' });
    }
  });
});

// Mobile menu toggle (if needed)
const mobileMenu = document.querySelector('[data-mobile-menu]');
const mobileToggle = document.querySelector('[data-mobile-toggle]');
if (mobileMenu && mobileToggle) {
  mobileToggle.addEventListener('click', () => {
    mobileMenu.classList.toggle('hidden');
  });
}

// Form handling (if forms exist)
document.querySelectorAll('form').forEach(form => {
  form.addEventListener('submit', function(e) {
    e.preventDefault();
    // Add your form handling here
    console.log('Form submitted:', new FormData(form));
  });
});`;

  // Add files to ZIP
  zip.file('index.html', indexHTML);
  zip.file('styles.css', stylesCSS);
  zip.file('script.js', scriptJS);
  
  // Add README
  zip.file('README.md', `# Grid 2.0 Export

Generated on: ${new Date().toISOString()}

## Structure
- \`index.html\` - Main HTML file
- \`styles.css\` - Extracted and optimized styles  
- \`script.js\` - Minimal interaction scripts

## Deployment

### Option 1: Static hosting
Upload all files to any static host (Netlify, Vercel, GitHub Pages, etc.)

### Option 2: Local preview
Open \`index.html\` in your browser

## Customization

### Colors
Edit CSS variables in \`styles.css\` under \`:root\`

### Content
Edit the HTML directly in \`index.html\`

### Fonts
Change font imports in the \`<head>\` section

---
Generated by Grid 2.0 - The AI website builder that actually works.`);

  // Generate ZIP buffer
  const zipData = await zip.generateAsync({ 
    type: 'nodebuffer',
    compression: 'DEFLATE',
    compressionOptions: { level: 9 }
  });
  
  return Buffer.from(zipData);
}

/**
 * Export as Next.js project
 */
async function exportAsNextJS(page: PageNode, includeSource: boolean): Promise<Buffer> {
  const zip = new JSZip();
  
  // Extract used components
  const usedComponents = extractUsedComponents(page.sections);
  
  // Package.json
  zip.file('package.json', JSON.stringify({
    name: 'grid20-nextjs-export',
    version: '1.0.0',
    private: true,
    scripts: {
      dev: 'next dev',
      build: 'next build',
      start: 'next start',
      lint: 'next lint'
    },
    dependencies: {
      next: '^14.0.0',
      react: '^18.2.0',
      'react-dom': '^18.2.0'
    },
    devDependencies: {
      '@types/node': '^20.0.0',
      '@types/react': '^18.2.0',
      '@types/react-dom': '^18.2.0',
      'autoprefixer': '^10.4.0',
      'postcss': '^8.4.0',
      'tailwindcss': '^3.4.0',
      'typescript': '^5.0.0'
    }
  }, null, 2));

  // tsconfig.json
  zip.file('tsconfig.json', JSON.stringify({
    compilerOptions: {
      target: 'ES2022',
      lib: ['dom', 'dom.iterable', 'esnext'],
      allowJs: true,
      skipLibCheck: true,
      strict: true,
      forceConsistentCasingInFileNames: true,
      noEmit: true,
      esModuleInterop: true,
      module: 'esnext',
      moduleResolution: 'bundler',
      resolveJsonModule: true,
      isolatedModules: true,
      jsx: 'preserve',
      incremental: true,
      paths: {
        '@/*': ['./*']
      }
    },
    include: ['next-env.d.ts', '**/*.ts', '**/*.tsx'],
    exclude: ['node_modules']
  }, null, 2));

  // tailwind.config.js
  zip.file('tailwind.config.js', `/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        brand: ${JSON.stringify(page.brand.colors.brand, null, 8)},
        gray: ${JSON.stringify(page.brand.colors.gray, null, 8)},
      },
      fontFamily: {
        heading: ['${page.brand.fonts.heading}', 'system-ui', 'sans-serif'],
        body: ['${page.brand.fonts.body}', 'system-ui', 'sans-serif'],
      },
    },
  },
  plugins: [],
}`);

  // app/layout.tsx
  zip.file('app/layout.tsx', `import type { Metadata } from 'next';
import './globals.css';

export const metadata: Metadata = {
  title: '${page.meta.title}',
  description: '${page.meta.description}',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}`);

  // app/globals.css
  zip.file('app/globals.css', `@tailwind base;
@tailwind components;
@tailwind utilities;`);

  // app/page.tsx
  zip.file('app/page.tsx', `import { PageRenderer } from '@/components/PageRenderer';

const pageData = ${JSON.stringify(page, null, 2)};

export default function Home() {
  return <PageRenderer page={pageData} />;
}`);

  // Add PageRenderer component
  zip.file('components/PageRenderer.tsx', `'use client';

import type { PageNode } from '@/types';
import { componentRegistry } from '@/components/sections/registry';

export function PageRenderer({ page }: { page: PageNode }) {
  return (
    <>
      {page.sections.map((section) => {
        const registryKey = \`\${section.meta.kind}-\${section.meta.variant}\`;
        const entry = componentRegistry[registryKey];
        
        if (!entry) {
          console.warn(\`Component not found: \${registryKey}\`);
          return null;
        }

        const Component = entry.component;
        
        return (
          <Component
            key={section.id}
            {...section.props}
          />
        );
      })}
    </>
  );
}`);

  // Add types
  zip.file('types/index.ts', await getTypeDefinitions());

  // Add components
  if (includeSource) {
    for (const [key, component] of usedComponents) {
      const source = await getComponentSource(key);
      if (source) {
        zip.file(`components/sections/${key}.tsx`, source);
      }
    }
    
    // Add registry
    zip.file('components/sections/registry.ts', await getRegistrySource(usedComponents));
  }

  // Add README
  zip.file('README.md', `# Grid 2.0 Next.js Export

## Getting Started

\`\`\`bash
# Install dependencies
npm install
# or
pnpm install

# Run development server
npm run dev
# or
pnpm dev
\`\`\`

Open [http://localhost:3000](http://localhost:3000) to see your site.

## Structure

- \`app/\` - Next.js app router files
- \`components/\` - React components
- \`types/\` - TypeScript definitions

## Deployment

### Vercel (Recommended)
\`\`\`bash
npx vercel
\`\`\`

### Other platforms
Build and export:
\`\`\`bash
npm run build
\`\`\`

---
Generated by Grid 2.0`);

  const zipData = await zip.generateAsync({ 
    type: 'nodebuffer',
    compression: 'DEFLATE',
    compressionOptions: { level: 9 }
  });
  
  return Buffer.from(zipData);
}

/**
 * Export as Remix project (bonus)
 */
async function exportAsRemix(page: PageNode): Promise<Buffer> {
  const zip = new JSZip();
  
  // Basic Remix setup
  zip.file('package.json', JSON.stringify({
    name: 'grid20-remix-export',
    version: '1.0.0',
    private: true,
    scripts: {
      build: 'remix build',
      dev: 'remix dev',
      start: 'remix-serve build'
    },
    dependencies: {
      '@remix-run/node': '^2.0.0',
      '@remix-run/react': '^2.0.0',
      '@remix-run/serve': '^2.0.0',
      'react': '^18.2.0',
      'react-dom': '^18.2.0'
    },
    devDependencies: {
      '@remix-run/dev': '^2.0.0',
      '@types/react': '^18.2.0',
      '@types/react-dom': '^18.2.0',
      'typescript': '^5.0.0'
    }
  }, null, 2));

  // Add Remix routes and components...
  // (Simplified for brevity)
  
  const zipData = await zip.generateAsync({ 
    type: 'nodebuffer',
    compression: 'DEFLATE'
  });
  
  return Buffer.from(zipData);
}

// ============================================
// Tailwind Extractor
// ============================================

// lib/export/tailwind-extractor.ts

/**
 * Extract Tailwind classes from HTML
 */
export function extractTailwindClasses(html: string): Set<string> {
  const classRegex = /class(?:Name)?=["']([^"']+)["']/g;
  const classes = new Set<string>();
  
  let match;
  while ((match = classRegex.exec(html)) !== null) {
    match[1].split(/\s+/).forEach(cls => {
      if (cls.trim()) {
        classes.add(cls.trim());
      }
    });
  }
  
  return classes;
}

/**
 * Generate minimal Tailwind CSS for used classes
 */
export async function generateTailwindCSS(
  classes: Set<string>,
  brand: any
): Promise<string> {
  // This would ideally use PostCSS with Tailwind's JIT compiler
  // For now, we'll generate a subset of common utilities
  
  const css: string[] = [];
  
  // Reset
  css.push(`*, ::before, ::after { box-sizing: border-box; margin: 0; }`);
  
  // Common utilities we know we use
  const utilities = {
    // Flexbox
    'flex': 'display: flex',
    'flex-col': 'flex-direction: column',
    'items-center': 'align-items: center',
    'justify-center': 'justify-content: center',
    'justify-between': 'justify-content: space-between',
    'gap-4': 'gap: 1rem',
    'gap-8': 'gap: 2rem',
    
    // Grid
    'grid': 'display: grid',
    'grid-cols-1': 'grid-template-columns: repeat(1, minmax(0, 1fr))',
    'grid-cols-2': 'grid-template-columns: repeat(2, minmax(0, 1fr))',
    'grid-cols-3': 'grid-template-columns: repeat(3, minmax(0, 1fr))',
    
    // Spacing
    'p-4': 'padding: 1rem',
    'p-8': 'padding: 2rem',
    'px-4': 'padding-left: 1rem; padding-right: 1rem',
    'px-6': 'padding-left: 1.5rem; padding-right: 1.5rem',
    'py-4': 'padding-top: 1rem; padding-bottom: 1rem',
    'py-8': 'padding-top: 2rem; padding-bottom: 2rem',
    'mt-4': 'margin-top: 1rem',
    'mt-8': 'margin-top: 2rem',
    'mx-auto': 'margin-left: auto; margin-right: auto',
    
    // Typography
    'text-sm': 'font-size: 0.875rem; line-height: 1.25rem',
    'text-base': 'font-size: 1rem; line-height: 1.5rem',
    'text-lg': 'font-size: 1.125rem; line-height: 1.75rem',
    'text-xl': 'font-size: 1.25rem; line-height: 1.75rem',
    'text-2xl': 'font-size: 1.5rem; line-height: 2rem',
    'text-3xl': 'font-size: 1.875rem; line-height: 2.25rem',
    'text-4xl': 'font-size: 2.25rem; line-height: 2.5rem',
    'font-semibold': 'font-weight: 600',
    'font-bold': 'font-weight: 700',
    'text-center': 'text-align: center',
    
    // Colors
    'text-white': 'color: white',
    'text-gray-900': 'color: #111827',
    'text-gray-600': 'color: #4b5563',
    'bg-white': 'background-color: white',
    'bg-gray-50': 'background-color: #f9fafb',
    'bg-gray-900': 'background-color: #111827',
    
    // Layout
    'max-w-7xl': 'max-width: 80rem',
    'w-full': 'width: 100%',
    'h-full': 'height: 100%',
    'min-h-screen': 'min-height: 100vh',
    
    // Border radius
    'rounded': 'border-radius: 0.25rem',
    'rounded-lg': 'border-radius: 0.5rem',
    'rounded-xl': 'border-radius: 0.75rem',
    'rounded-2xl': 'border-radius: 1rem',
    
    // Shadows
    'shadow': 'box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1)',
    'shadow-lg': 'box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1)',
    'shadow-xl': 'box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1)',
    
    // Transitions
    'transition-all': 'transition-property: all',
    'duration-200': 'transition-duration: 200ms',
    
    // Responsive prefixes
    'sm:grid-cols-2': '@media (min-width: 640px) { grid-template-columns: repeat(2, minmax(0, 1fr)) }',
    'lg:grid-cols-3': '@media (min-width: 1024px) { grid-template-columns: repeat(3, minmax(0, 1fr)) }',
  };
  
  // Add used utilities
  for (const cls of classes) {
    if (utilities[cls as keyof typeof utilities]) {
      css.push(`.${cls} { ${utilities[cls as keyof typeof utilities]} }`);
    }
  }
  
  // Add responsive utilities
  css.push(`
@media (min-width: 640px) {
  .sm\\:text-4xl { font-size: 2.25rem; line-height: 2.5rem; }
  .sm\\:text-5xl { font-size: 3rem; line-height: 1; }
  .sm\\:py-32 { padding-top: 8rem; padding-bottom: 8rem; }
}

@media (min-width: 1024px) {
  .lg\\:text-6xl { font-size: 3.75rem; line-height: 1; }
  .lg\\:grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
  .lg\\:px-8 { padding-left: 2rem; padding-right: 2rem; }
}
  `);
  
  return css.join('\n');
}

// ============================================
// Component Extractor  
// ============================================

// lib/export/component-extractor.ts

export function extractUsedComponents(
  sections: SectionNode[]
): Map<string, any> {
  const used = new Map();
  
  for (const section of sections) {
    const key = `${section.meta.kind}-${section.meta.variant}`;
    const entry = componentRegistry[key];
    if (entry) {
      used.set(key, entry);
    }
  }
  
  return used;
}

async function getComponentSource(key: string): Promise<string> {
  // In production, this would read from filesystem
  // For now, return a placeholder
  return `// Component: ${key}
// Source would be extracted from filesystem
export function Component() {
  return <div>Component ${key}</div>;
}`;
}

async function getRegistrySource(
  usedComponents: Map<string, any>
): Promise<string> {
  const imports = Array.from(usedComponents.keys())
    .map(key => `import { ${key.replace('-', '_')} } from './${key}';`)
    .join('\n');
    
  const exports = Array.from(usedComponents.entries())
    .map(([key, entry]) => `  '${key}': { component: ${key.replace('-', '_')}, meta: ${JSON.stringify(entry.meta, null, 2)} },`)
    .join('\n');
    
  return `${imports}

export const componentRegistry = {
${exports}
};`;
}

async function getTypeDefinitions(): Promise<string> {
  // Return core type definitions
  return `// Type definitions for Grid 2.0 export

export type SectionKind = 'hero' | 'features' | 'about' | 'testimonials' | 'cta' | 'footer';

export type Tone = 'minimal' | 'bold' | 'playful' | 'corporate';

export interface SectionNode {
  id: string;
  meta: any;
  props: any;
  position: number;
}

export interface PageNode {
  sections: SectionNode[];
  meta: any;
  brand: any;
  audits: any;
}

// Add more types as needed...`;
}